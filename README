# dfsweo
Designing for Scalability with Erlang/OTP
Steve Vinoski, Francesco Cesarini
O'Reilly Media, Inc.
2016

Chapter 1. Introduction

Scalable refers to how well a computing system can adapt to changes in load or
available resources.

Distributed refers to how systems are clustered together and interact with each
other.

Systems that are fault tolerant continue to operate predictably when things in
their environment are failing.

By soft real-time, we mean the predictability of response and latency, handling
a constant throughput, and guaranteeing a response within an acceptable time
frame.

High availability minimizes or completely eliminates downtime as a result of
bugs, outages, upgrades, or other operational activities.

OTP is a domain-independent set of frameworks, principles, and patterns that
guide and support the structure, design, implementation, and deployment of
Erlang systems.

Chapter 2. Introducing Erlang

Recursion and Pattern Matching

Functional Influence
  Fun with Anonymous Functions
  List Comprehensions: Generate and Test

Processes and Message Passing

Fail Safe!

Links and Monitors for Supervision

  Links

    Reason  Trapping exits                  Not trapping exits
    ----------------------------------------------------------
    normal  Receives {'EXIT', Pid, normal}  Nothing happens
    kill    Terminates with reason killed   Terminates with reason killed
    Other   Receives {'EXIT', Pid, Other}   Terminates with reason Other

  Monitors

Records

Maps

Macros

Upgrading Modules

ETS: Erlang Term Storage

  Set
    Each key-value tuple can occur only once.
  Bag
    Each key-value tuple combination can only occur once, but a key can appear
    multiple times.
  Duplicate bag
    Tuples can be duplicated.
  Ordered set
    These have the same restriction as sets, but the tuples can be visited
    in order by key.

  public
    Accessible to all processes.
  private
    Accessible to the owning process only.
  protected
    All processes can read the table, but only the owner can write to it.

Distributed Erlang

Chapter 3. Behaviors

Process Skeletons

  Be spawned and initialized
  Repeatedly receive messages, handle them, and send replies
  Be terminated (normally or abnormally)

Design Patterns

  Generic                         Specific
  ----------------------------------------
  Spawning the server             Initializing the server state
  Storing the loop data           The loop data
  Sending requests to the server  The client requests
  Sending replies to the client   Handling client requests
  Receiving server replies        Contents of server reply
  Stopping the server             Cleaning up

  behavior module + callback module

  Generic server
    Used to model client-server behaviors
  Generic finite state machine
    Used for FSM programming
  Generic event handler/manager
    Used for writing event handlers
  Supervisor
    Used for fault-tolerant supervision trees
  Application
    Used to encapsulate resources and functionality

Extracting Generic Behaviors

The Generic Server

Message Passing: Under the Hood

Chapter 4. Generic Servers

Generic Servers

  gen_server
    start and stop the server
    send synchronous and asynchronous messages
    software upgrade
    timeout

Behavior Directives

Starting a Server

  gen_server:start_link({local, Name}, Mod, Args, Opts) ->
      {ok, Pid} | ignore | {error, Reason}
  Mod:init(Args) ->
      {ok, LoopData} | ignore | {stop, Reason}

  Starting a generic server behavior process is a synchronous operation.

Message Passing

  Synchronous Message Passing

    gen_server:call(Name, Message) ->
        Reply
    Mod:handle_call(Message, From, LoopData) ->
        {reply, Reply, NewLoopData} | {stop, Reason, Reply, LoopData}

  Asynchronous Message Passing
`
    gen_server:cast(Name, Message) ->
        ok
    Mod:handle_cast(Message, LoopData) ->
        {noreply, NewLoopData} | {stop, Reason, LoopData}

  Other Messages

    Mod:handle_info(Message, LoopData) ->
        {noreply, LoopData} | {stop, Reason, LoopData}

  Unhandled Messages

  Synchronizing Clients

Termination

  Mod:terminate(Reason, LoopData) -> Term

Call Timeouts

  gen_server:call(Server, Message, TimeOut) -> Reply

Deadlocks

  Yound call old
  Old cast yound

Generic Server Timeouts

  gen_server timeout
  erlang:send_after/3
  timer
    apply_after/3
    send_after/2
    apply_interval/4
    send_interval/2

  Hibernating Behaviors

Going Global

  gen_server:start_link({global,Name},Mod,Args,Opts) ->
      {ok, Pid} | ignore | {error, Reason}
  gen_server:call({global, Name}, Message) -> Reply
  gen_server:cast({global, Name}, Message) -> ok

  gen_server:start_link({via, Module, Name},Mod,Args,Opts) -> {ok, Pid}
  gen_server:call({via, Module, Name}, Message) -> Reply
  gen_server:cast({via, Module, Name}, Message) -> ok

  gen_server:start_link(Mod, Args, Opts) ->
      {ok, Pid} | ignore | {error, Reason}

  gen_server:multi_call(Nodes, Name, Request [, Timeout]) ->
      {[{Node,Reply}], BadNodes}
  gen_server:abcast(Nodes, Name, Request) -> abcast

Linking Behaviors

  gen_server:start(NameScope,Mod,Args,Opts)
  gen_server:start(Mod,Args,Opts) ->
      {ok, Pid} | {error, {already_started, Pid}}

Chapter 5. Controlling OTP Behaviors

The sys Module

  Tracing and Logging

    sys:trace/2
    sys:log/2
    sys:log_to_file/2

  System Messages

    {in, Msg}
    {out, Msg, To, State}
    term()

  Your Own Trace Functions

    sys:install/2
    sys:remove/2

  Statistics, Status, and State

    sys:statistics/2
    sys:get_status/1
    sys:suspend/1
    sys:resume/1
    sys:get_state/1
    sys:replace_state/2

  The sys Module Recap

    sys:trace(Name,TraceFlag [,Timeout]) -> ok

    sys:log(Name,LogFlag [,Timeout]) -> ok | {ok, EventList}
    sys:log_to_file(Name,FileFlag [,Timeout]) -> ok | {error, open_file}

    sys:install(Name,{Func,FuncState} [,Timeout]) -> ok
    sys:remove(Name,Func [,Timeout])

    sys:statistics(Name,Flag [,Timeout]) -> ok | {ok, Statistics}.

    sys:get_status(Name [,Timeout]) -> {status, Pid, {module, Mod}, Status}

    sys:get_state(Name [,Timeout]) -> State

    sys:replace_state(Name,ReplaceFun [,Timeout]) -> State

    sys:suspend(Name [,Timeout]) -> ok
    sys:resume(Name [,Timeout]) -> ok

Spawn Options

  Memory Management and Garbage Collection

    min_heap_size
    min_bin_vheap_size
    fullsweep_after

  Spawn Options to Avoid

    monitor
    link
    priority

Timeouts

  Avoid timeout in init. Prefer working less.
